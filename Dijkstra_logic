import numpy as np
import cv2

def mapDef(start_position,goal_position,updated_map_point_robot)
display_map = updated_map_point_robot
    print(display_map.shape)

    plt.figure(figsize=(100,200))

    for i in range(0,display_map.shape[0]):
        for j in range(0,display_map.shape[1]):
            if display_map[i,j] == 1:
                plt.plot(j,100-i,'k.')
                
    plt.xlim(0,200)
    plt.ylim(0,100)
    plt.grid(True)
    plt.show()

def startNode():
    x1 = int (input("Enter an x1 coordinate: "))
    y1 = int (input("Enter an y1 coordinate: "))
    start_node = []

    if x1 not in range(0,200) or y1 not in range(0,100):
        print("Position not permitted")
        exit()
    if x1 in range(90,110) or y1 in range(40,60):
        print("Position not permitted")
        exit()
    else:
        start_node.append(x1,y1)
    
    return start_node

def goalNode():
    x2 = int(input("enter the goal x coordinate"))
    y2 = int(input("enter the goal y coordinate"))
    
    goal_node = []

    if x2 not in range(0,200) or y2 not in range(0,100):
        print("Position not permitted")
        exit()
    if x2 in range(90,110) or y2 in range(40,60):
        print("Position not permitted")
        exit()
    else:
        goal_node.append(x2,y2)
    
    return goal_node

height, width = 100, 200
img = np.zeros((height, width, 3), np.uint8)
img[:, :] = [255, 255, 255]


def circle(x,y):
    cv2.circle(img1,(225,50), 25, (0,255,0), -1)
#     cv2.imwrite("final_map.jpg", img1)
    cv2.imshow('image', img1)
    return img1

def polygon():
    pts = np.array([[25,15],[75,15],[100,50],[75,80],[50,50],[20,80]], np.int32)
    pts = pts.reshape((-1,1,2))
    cv2.polylines(img1,[pts],True,(0,0,255),1)
#     cv2.imwrite("final_map.jpg", img1)
    cv2.imshow('image', img1)
    return img1

def rod():
    pts1 = np.array([[95,170],[30.88,133.5],[36.72,128.95],[100,161.45]], np.int32)
    pts1 = pts1.reshape((-1,1,2))
    cv2.polylines(img1,[pts1],True,(0,0,255),1)
#     cv2.imwrite("final_map.jpg", img1)
    cv2.imshow('image', img1)
    return img1

def rhombus():
    pts2 = np.array([[200,175],[225,160],[250,175],[225,190]], np.int32)
    pts2= pts2.reshape((-1,1,2))
    cv2.polylines(img1,[pts2],True,(0,0,255),1)
#     cv2.imwrite("final_map.jpg", img1)
    cv2.imshow('image', img1)
    return img1

def ellipse():
    img1=cv2.ellipse(img1,(150,100),(40,20),0,0,360,255,-1)
#     cv2.imwrite("final_map.jpg", img1)
    cv2.imshow('image', img1)
    return img1


#defining obstacles and the rejecting points inside them by detecting contours.

image = cv2.imread('final_map.jpg')
image = cv2.imshow('image', image)
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
canny = cv2.Canny(gray, 120, 255, 1)
cnts = cv2.findContours(canny, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cnts = cnts[0] if len(cnts) == 2 else cnts[1]

for c in cnts:
    cv2.drawContours(image, [c], -1, (36, 255, 12), 2)
    result = cv2.pointPolygonTest(c, point1, False)
print(result)

cv2.imshow('image', image)
cv2.waitKey()


import sys
import math


def check_obstacle(node):
   # check
   return True

def explore(node, goal, i_cap, j_cap, parent_distance):
   if node[0] < 0 or node[1] < 0 or node[0]>i_cap or node[1]>j_cap:
       return 0
   i = node[0]
   j = node[1]

   if node[0] == goal[0] and node[1] == goal[1]:
       return 1

   paths = [(i,j+1),(i+1,j),(i+1,j+1)]
   valid_paths = []
   for path in paths:
       if check_obstacle(path):
           pass
       valid_paths.append(path)

   min_dist = 100000
   min_path = None
   for path in valid_paths:
       distance = (path[0]-node[0]+path[1]-node[1])
       if distance == 2 :
           actual_distance = math.sqrt(2)+parent_distance
       if distance == -2 :
           actual_distance = parent_distance - math.sqrt(2)
       if distance == 1 :
           actual_distance = 1+parent_distance
       if distance == -1 :
           actual_distance = parent_distance - 1
       possibilty = explore(path, goal, i_cap, j_cap, actual_distance)
       if possibilty == 1 :
           if actual_distance < min_dist:
               min_path = path
   if min_path == None:
       return 0
   else:
       return 1

explore((5,5), (195,295), 200, 300, 0)
